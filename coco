#!/usr/bin/env bash
#  Sandboxed execution for untrusted dev tools in one script.
#  https://github.com/AdrianVollmer/ContainerConductor
#  MIT Licensed

set -euo pipefail

if [[ "${COCO_DEBUG:-}" == "true" || "${COCO_DEBUG:-}" == "1" ]]; then
	set -x
fi

PRODUCT="coco"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/$PRODUCT"
CONFIG_FILE="$CONFIG_DIR/config.json"
CONFIG_D_DIR="$CONFIG_DIR/config.d"

# Container runtime: "podman" (default) or "docker"
COCO_RUNTIME="${COCO_RUNTIME:-podman}"

# Container image (mise's image + uvx)
COCO_IMAGE="${COCO_IMAGE:-localhost/coco:latest}"

# Default allowed hosts for common package registries
DEFAULT_ALLOWED_HOSTS=(
	# Python/pip
	pypi.org
	files.pythonhosted.org
	# Rust/cargo
	crates.io
	static.crates.io
	index.crates.io
	# Go
	proxy.golang.org
	sum.golang.org
	storage.googleapis.com
	# npm
	registry.npmjs.org
	# Ruby
	rubygems.org
	# GitHub
	github.com
	raw.githubusercontent.com
	objects.githubusercontent.com
	codeload.github.com
)

# shellcheck disable=SC2016
DOCKERFILE='FROM ghcr.io/astral-sh/uv:latest AS uv

FROM ghcr.io/jdx/mise:latest
COPY --from=uv /uv /uvx /usr/local/bin/

RUN apt-get update && apt-get install -y --no-install-recommends dnsmasq \
    && rm -rf /var/lib/apt/lists/*

ENV MISE_DATA_DIR="/root/.local/share/mise"
ENV MISE_CACHE_DIR="/root/.cache/mise"
ENV MISE_CONFIG_DIR="/root/.config/mise"
ENV GOROOT="/root/.local/share/go"
ENV CARGO_HOME="/root/.cache/cargo"
ENV CARGO_TARGET_DIR="/root/.local/bin"
ENV PATH="/root/.local/bin:/root/.local/share/mise/shims:$GOROOT/bin:$PATH"

RUN mkdir -p /workspace

COPY <<-"ENTRYPOINT" /usr/local/bin/coco-entrypoint
#!/bin/sh
set -e

if [ -n "$COCO_ALLOWED_HOSTS" ]; then
    upstream="${COCO_UPSTREAM_DNS:-8.8.8.8}"

    # Generate dnsmasq config: block all except allowed hosts
    {
        echo "no-resolv"
        echo "no-hosts"
        echo "listen-address=127.0.0.1"
        echo "bind-interfaces"
        # Return NXDOMAIN for everything by default
        echo "address=/#/"
        # Allow specific hosts
        echo "$COCO_ALLOWED_HOSTS" | tr "," "\n" | while read -r host; do
            [ -n "$host" ] && echo "server=/$host/$upstream"
        done
    } > /etc/dnsmasq.conf

    # Point resolver to local dnsmasq
    echo "nameserver 127.0.0.1" > /etc/resolv.conf

    # Start dnsmasq
    dnsmasq

    unset COCO_ALLOWED_HOSTS COCO_UPSTREAM_DNS
fi

exec mise "$@"
ENTRYPOINT
RUN chmod +x /usr/local/bin/coco-entrypoint

ENTRYPOINT ["/usr/local/bin/coco-entrypoint"]
'

# Populated by run_tool and load_config
TOOL_NAME=""
TOOL_CONFIG=""
MERGED_CONFIG=""

# Accumulated container runtime arguments
PODMAN_ARGS=()

# =============================================================================
# Utility functions
# =============================================================================

die() {
	echo "error: $*" >&2
	exit 1
}

cfg() {
	echo "$TOOL_CONFIG" | jq -r "$1"
}

cfg_array() {
	echo "$TOOL_CONFIG" | jq -r "$1"
}

load_merged_config() {
	if [[ -n "$MERGED_CONFIG" ]]; then
		return
	fi

	local configs=()

	if [[ -f "$CONFIG_FILE" ]]; then
		configs+=("$CONFIG_FILE")
	fi

	if [[ -d "$CONFIG_D_DIR" ]]; then
		for f in "$CONFIG_D_DIR"/*.json; do
			if [[ -f "$f" ]]; then
				configs+=("$f")
			fi
		done
	fi

	if [[ ${#configs[@]} -eq 0 ]]; then
		die "no config found in $CONFIG_FILE or $CONFIG_D_DIR/*.json"
	fi

	# Merge all config files (later files override earlier ones)
	MERGED_CONFIG="$(jq -s 'reduce .[] as $item ({}; . * $item)' "${configs[@]}")"
}

require_config() {
	load_merged_config
}

list_tools() {
	load_merged_config
	echo "$MERGED_CONFIG" | jq -r 'keys[]'
}

# =============================================================================
# Initialization
# =============================================================================

check_dependencies() {
	command -v jq &>/dev/null || die "jq is required but not installed"

	case "$COCO_RUNTIME" in
	podman | docker) ;;
	*) die "COCO_RUNTIME must be 'podman' or 'docker', got '$COCO_RUNTIME'" ;;
	esac

	command -v "$COCO_RUNTIME" &>/dev/null ||
		die "$COCO_RUNTIME is required but not installed"
}

ensure_image() {
	if "$COCO_RUNTIME" image exists "$COCO_IMAGE" 2>/dev/null; then
		return
	fi

	echo "Building $COCO_IMAGE..." >&2
	echo "$DOCKERFILE" | "$COCO_RUNTIME" build --format docker -t "$COCO_IMAGE" -f - .
}

load_config() {
	load_merged_config

	TOOL_CONFIG="$(echo "$MERGED_CONFIG" | jq -e --arg t "$TOOL_NAME" '.[$t]' 2>/dev/null)" ||
		die "no config for '$TOOL_NAME'"
}

# =============================================================================
# Podman argument builders
# =============================================================================

add_base_args() {
	PODMAN_ARGS+=(run --rm --init)

	# TTY: only attach interactive terminal when stdin is a tty
	if [[ -t 0 ]]; then
		PODMAN_ARGS+=(-it)
	fi
}

add_volumes() {
	local config="${XDG_CONFIG_HOME:-$HOME/.config}/mise"
	mkdir -p "${config}"
	PODMAN_ARGS+=(
		-v coco_xdg_cache:/root/.cache
		-v coco_xdg_data:/root/.local
		-v coco_cargo_home:/usr/local/cargo
		-v "${config}:/root/.config/mise"
	)
}

add_network() {
	# Allow temporary network access override
	if [[ "${COCO_ALLOW_NETWORK:-}" == "true" || "${COCO_ALLOW_NETWORK:-}" == "1" ]]; then
		return
	fi

	local network
	network="$(cfg '.network // empty')"
	if [[ -n "$network" ]]; then
		PODMAN_ARGS+=(--network "$network")
	fi
}

add_mounts() {
	local mount src dst opts
	while IFS= read -r mount; do
		[[ "$mount" == "null" || -z "$mount" ]] && continue

		src="$(echo "$mount" | jq -r '.src')"
		dst="$(echo "$mount" | jq -r '.dst')"
		opts="$(echo "$mount" | jq -r '.opts // empty')"

		# Expand ~ and . in source path
		src="${src/#\~/$HOME}"
		if [[ "$src" == "." ]]; then
			src="$PWD"
		fi
		src="$(realpath -m "$src")"

		# Create host dir if it doesn't exist (avoid podman creating it as root)
		if [[ ! -e "$src" ]]; then
			mkdir -p "$src"
		fi

		if [[ -n "$opts" ]]; then
			PODMAN_ARGS+=(-v "$src:$dst:$opts")
		else
			PODMAN_ARGS+=(-v "$src:$dst")
		fi
	done < <(cfg_array '.mounts // [] | .[]' | jq -c '.')
}

add_env_passthrough() {
	local var
	while IFS= read -r var; do
		[[ -z "$var" ]] && continue
		if [[ -v "$var" ]]; then
			PODMAN_ARGS+=(-e "$var=${!var}")
		fi
	done < <(cfg_array '.env_passthrough // [] | .[]')
}

add_env_explicit() {
	local kv
	while IFS= read -r kv; do
		[[ -z "$kv" ]] && continue
		PODMAN_ARGS+=(-e "$kv")
	done < <(cfg_array '.env // {} | to_entries[] | "\(.key)=\(.value)"')
}

add_allowed_hosts() {
	local user_hosts all_hosts
	user_hosts="$(cfg_array '.allowed_hosts // [] | join(",")')"
	if [[ -n "$user_hosts" ]]; then
		# Merge default hosts with user-specified hosts
		local IFS=','
		all_hosts="${DEFAULT_ALLOWED_HOSTS[*]},$user_hosts"
		PODMAN_ARGS+=(-e "COCO_ALLOWED_HOSTS=$all_hosts")
		# Pass host's DNS server to container
		local upstream
		upstream="$(grep -m1 '^nameserver' /etc/resolv.conf | awk '{print $2}')"
		PODMAN_ARGS+=(-e "COCO_UPSTREAM_DNS=${upstream:-8.8.8.8}")
	fi
}

add_ports() {
	local port
	while IFS= read -r port; do
		[[ -z "$port" ]] && continue
		PODMAN_ARGS+=(-p "$port")
	done < <(cfg_array '.ports // [] | .[]')

	# Extra ports from environment variable (CSV)
	if [[ -n "${COCO_EXTRA_PORTS:-}" ]]; then
		local extra_ports
		IFS=',' read -ra extra_ports <<<"$COCO_EXTRA_PORTS"
		for port in "${extra_ports[@]}"; do
			[[ -z "$port" ]] && continue
			PODMAN_ARGS+=(-p "$port")
		done
	fi
}

add_extra_args() {
	local extra
	while IFS= read -r extra; do
		[[ -z "$extra" ]] && continue
		PODMAN_ARGS+=("$extra")
	done < <(cfg_array '.podman_args // [] | .[]')
}

add_workdir() {
	local workdir
	workdir="$(cfg '.workdir // "/workspace"')"
	PODMAN_ARGS+=(-w "$workdir")
}

build_podman_args() {
	add_base_args
	add_volumes
	add_network
	add_mounts
	add_env_passthrough
	add_env_explicit
	add_allowed_hosts
	add_ports
	add_extra_args
	add_workdir
}

# =============================================================================
# Management commands
# =============================================================================

cmd_list() {
	require_config
	list_tools
}

cmd_up() {
	require_config

	local coco_path bin_dir tool
	coco_path="$(realpath "$0")"
	bin_dir="$HOME/.local/bin"

	mkdir -p "$bin_dir"

	for tool in $(list_tools); do
		local link_path="$bin_dir/$tool"
		if [[ -L "$link_path" ]]; then
			echo "exists: $tool"
		elif [[ -e "$link_path" ]]; then
			echo "skip: $tool (file exists and is not a symlink)"
		else
			ln -s "$coco_path" "$link_path"
			echo "created: $tool -> $coco_path"
		fi
	done
}

cmd_down() {
	require_config

	local bin_dir tool
	bin_dir="$HOME/.local/bin"

	for tool in $(list_tools); do
		local link_path="$bin_dir/$tool"
		if [[ -L "$link_path" ]]; then
			rm "$link_path"
			echo "removed: $tool"
		elif [[ -e "$link_path" ]]; then
			echo "skip: $tool (exists but is not a symlink)"
		else
			echo "skip: $tool (not found)"
		fi
	done
}

cmd_prune() {
	local volumes=(coco_xdg_cache)
	echo "Removing cache volumes..."
	for vol in "${volumes[@]}"; do
		if "$COCO_RUNTIME" volume rm "$vol" 2>/dev/null; then
			echo "removed: $vol"
		else
			echo "skip: $vol (not found or in use)"
		fi
	done

	# Clean downloads from the data volume (keep installed tools)
	echo "Cleaning mise downloads..."
	if "$COCO_RUNTIME" volume exists coco_xdg_data 2>/dev/null; then
		"$COCO_RUNTIME" run --rm -v coco_xdg_data:/data docker.io/library/alpine \
			rm -rf /data/share/mise/downloads 2>/dev/null &&
			echo "removed: mise downloads" ||
			echo "skip: mise downloads (not found or failed)"
	else
		echo "skip: mise downloads (volume not found)"
	fi
}

cmd_rebuild() {
	echo "Rebuilding $COCO_IMAGE..."
	echo "$DOCKERFILE" | "$COCO_RUNTIME" build --format docker --pull --no-cache -t "$COCO_IMAGE" -f - .
	echo "done"
}

cmd_help() {
	cat <<-EOF
		Usage: $PRODUCT <command> [args...]

		Commands:
		  run <tool> [args...]   Run a tool in a container
		  list                   List all configured tools
		  up                     Create symlinks for all tools
		  down                   Remove symlinks for all tools
		  prune                  Remove mise cache volumes
		  rebuild                Rebuild the container image

		Symlink invocation:
		  <tool> [args...]       Run via symlink (after 'up')

		Environment:
		  COCO_RUNTIME        Container runtime: podman (default) or docker
		  COCO_IMAGE          Container image (default: localhost/coco:latest)
		  COCO_DEBUG          Enable debug output (set to 'true' or '1')
		  COCO_ALLOW_NETWORK  Override network restrictions (set to 'true' or '1')
		  COCO_EXTRA_PORTS    Additional ports to publish (CSV, e.g. '8080:8080,3000:3000')
	EOF
}

# =============================================================================
# Tool execution
# =============================================================================

run_tool() {
	TOOL_NAME="$1"
	shift
	REMAINING_ARGS=("$@")

	check_dependencies
	ensure_image
	load_config
	build_podman_args

	local command mise_tool cmd
	command="$(cfg '.command // empty')"
	mise_tool="$(cfg '.tool')"
	cmd="${command:-$TOOL_NAME}"

	exec "$COCO_RUNTIME" "${PODMAN_ARGS[@]}" "$COCO_IMAGE" x "$mise_tool" -- "$cmd" "${REMAINING_ARGS[@]}"
}

# =============================================================================
# Main
# =============================================================================

main() {
	local script_name
	script_name="$(basename "$0")"

	# Symlink invocation: run as tool directly
	if [[ "$script_name" != "$PRODUCT" ]]; then
		run_tool "$script_name" "$@"
		return
	fi

	# Direct invocation: parse command
	if [[ $# -lt 1 ]]; then
		cmd_help
		exit 1
	fi

	local cmd="$1"
	shift

	case "$cmd" in
	run)
		if [[ $# -lt 1 ]]; then
			die "usage: $PRODUCT run <tool> [args...]"
		fi
		run_tool "$@"
		;;
	list) cmd_list ;;
	up) cmd_up ;;
	down) cmd_down ;;
	prune) cmd_prune ;;
	rebuild) cmd_rebuild ;;
	help | --help | -h) cmd_help ;;
	*) die "unknown command: $cmd (see '$PRODUCT help')" ;;
	esac
}

main "$@"
