#!/usr/bin/env bash
#  A single bash script for running isolated tools via mise.
#  https://github.com/AdrianVollmer/ContainerConductor
#  MIT Licensed

set -euo pipefail

if [[ "${COCO_DEBUG:-}" == "true" || "${COCO_DEBUG:-}" == "1" ]]; then
	set -x
fi

PRODUCT="coco"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/$PRODUCT"
CONFIG_FILE="$CONFIG_DIR/config.json"
CONFIG_D_DIR="$CONFIG_DIR/config.d"

# Container runtime: "podman" (default) or "docker"
COCO_RUNTIME="${COCO_RUNTIME:-podman}"

# Populated by run_tool and load_config
TOOL_NAME=""
TOOL_CONFIG=""
MERGED_CONFIG=""

# Accumulated container runtime arguments
PODMAN_ARGS=()

# =============================================================================
# Utility functions
# =============================================================================

die() {
	echo "error: $*" >&2
	exit 1
}

cfg() {
	echo "$TOOL_CONFIG" | jq -r "$1"
}

cfg_array() {
	echo "$TOOL_CONFIG" | jq -r "$1"
}

load_merged_config() {
	if [[ -n "$MERGED_CONFIG" ]]; then
		return
	fi

	local configs=()

	if [[ -f "$CONFIG_FILE" ]]; then
		configs+=("$CONFIG_FILE")
	fi

	if [[ -d "$CONFIG_D_DIR" ]]; then
		for f in "$CONFIG_D_DIR"/*.json; do
			if [[ -f "$f" ]]; then
				configs+=("$f")
			fi
		done
	fi

	if [[ ${#configs[@]} -eq 0 ]]; then
		die "no config found in $CONFIG_FILE or $CONFIG_D_DIR/*.json"
	fi

	# Merge all config files (later files override earlier ones)
	MERGED_CONFIG="$(jq -s 'reduce .[] as $item ({}; . * $item)' "${configs[@]}")"
}

require_config() {
	load_merged_config
}

list_tools() {
	load_merged_config
	echo "$MERGED_CONFIG" | jq -r 'keys[]'
}

# =============================================================================
# Initialization
# =============================================================================

check_dependencies() {
	command -v jq &>/dev/null || die "jq is required but not installed"

	case "$COCO_RUNTIME" in
	podman | docker) ;;
	*) die "COCO_RUNTIME must be 'podman' or 'docker', got '$COCO_RUNTIME'" ;;
	esac

	command -v "$COCO_RUNTIME" &>/dev/null ||
		die "$COCO_RUNTIME is required but not installed"
}

load_config() {
	load_merged_config

	TOOL_CONFIG="$(echo "$MERGED_CONFIG" | jq -e --arg t "$TOOL_NAME" '.[$t]' 2>/dev/null)" ||
		die "no config for '$TOOL_NAME'"
}

# =============================================================================
# Podman argument builders
# =============================================================================

add_base_args() {
	PODMAN_ARGS+=(run --rm --init)

	# TTY: only attach interactive terminal when stdin is a tty
	if [[ -t 0 ]]; then
		PODMAN_ARGS+=(-it)
	fi
}

add_mise_volumes() {
	PODMAN_ARGS+=(
		-v mise_installs:/mise/installs
		-v mise_downloads:/mise/downloads
		-v mise_shims:/mise/shims
		-v mise_cache:/mise/cache
		-v cargo_home:/usr/local/cargo
	)
}

add_network() {
	# Allow temporary network access override
	if [[ "${COCO_ALLOW_NETWORK:-}" == "true" || "${COCO_ALLOW_NETWORK:-}" == "1" ]]; then
		return
	fi

	local network
	network="$(cfg '.network // empty')"
	if [[ -n "$network" ]]; then
		PODMAN_ARGS+=(--network "$network")
	fi
}

add_mounts() {
	local mount src dst opts
	while IFS= read -r mount; do
		[[ "$mount" == "null" || -z "$mount" ]] && continue

		src="$(echo "$mount" | jq -r '.src')"
		dst="$(echo "$mount" | jq -r '.dst')"
		opts="$(echo "$mount" | jq -r '.opts // empty')"

		# Expand ~ and . in source path
		src="${src/#\~/$HOME}"
		if [[ "$src" == "." ]]; then
			src="$PWD"
		fi
		src="$(realpath -m "$src")"

		# Create host dir if it doesn't exist (avoid podman creating it as root)
		if [[ ! -e "$src" ]]; then
			mkdir -p "$src"
		fi

		if [[ -n "$opts" ]]; then
			PODMAN_ARGS+=(-v "$src:$dst:$opts")
		else
			PODMAN_ARGS+=(-v "$src:$dst")
		fi
	done < <(cfg_array '.mounts // [] | .[]' | jq -c '.')
}

add_env_passthrough() {
	local var
	while IFS= read -r var; do
		[[ -z "$var" ]] && continue
		if [[ -v "$var" ]]; then
			PODMAN_ARGS+=(-e "$var=${!var}")
		fi
	done < <(cfg_array '.env_passthrough // [] | .[]')
}

add_env_explicit() {
	local kv
	while IFS= read -r kv; do
		[[ -z "$kv" ]] && continue
		PODMAN_ARGS+=(-e "$kv")
	done < <(cfg_array '.env // {} | to_entries[] | "\(.key)=\(.value)"')
}

add_ports() {
	local port
	while IFS= read -r port; do
		[[ -z "$port" ]] && continue
		PODMAN_ARGS+=(-p "$port")
	done < <(cfg_array '.ports // [] | .[]')
}

add_extra_args() {
	local extra
	while IFS= read -r extra; do
		[[ -z "$extra" ]] && continue
		PODMAN_ARGS+=("$extra")
	done < <(cfg_array '.podman_args // [] | .[]')
}

add_workdir() {
	local workdir
	workdir="$(cfg '.workdir // "/workspace"')"
	PODMAN_ARGS+=(-w "$workdir")
}

build_podman_args() {
	add_base_args
	add_mise_volumes
	add_network
	add_mounts
	add_env_passthrough
	add_env_explicit
	add_ports
	add_extra_args
	add_workdir
}

# =============================================================================
# Management commands
# =============================================================================

cmd_list() {
	require_config
	list_tools
}

cmd_up() {
	require_config

	local coco_path bin_dir tool
	coco_path="$(realpath "$0")"
	bin_dir="$HOME/.local/bin"

	mkdir -p "$bin_dir"

	for tool in $(list_tools); do
		local link_path="$bin_dir/$tool"
		if [[ -L "$link_path" ]]; then
			echo "exists: $tool"
		elif [[ -e "$link_path" ]]; then
			echo "skip: $tool (file exists and is not a symlink)"
		else
			ln -s "$coco_path" "$link_path"
			echo "created: $tool -> $coco_path"
		fi
	done
}

cmd_down() {
	require_config

	local bin_dir tool
	bin_dir="$HOME/.local/bin"

	for tool in $(list_tools); do
		local link_path="$bin_dir/$tool"
		if [[ -L "$link_path" ]]; then
			rm "$link_path"
			echo "removed: $tool"
		elif [[ -e "$link_path" ]]; then
			echo "skip: $tool (exists but is not a symlink)"
		else
			echo "skip: $tool (not found)"
		fi
	done
}

cmd_prune() {
	local volumes=(mise_installs mise_downloads mise_shims mise_cache cargo_home)
	echo "Removing cache volumes..."
	for vol in "${volumes[@]}"; do
		if "$COCO_RUNTIME" volume rm "$vol" 2>/dev/null; then
			echo "removed: $vol"
		else
			echo "skip: $vol (not found or in use)"
		fi
	done
}

cmd_help() {
	cat <<-EOF
		Usage: $PRODUCT <command> [args...]

		Commands:
		  run <tool> [args...]   Run a tool in a container
		  list                   List all configured tools
		  up                     Create symlinks for all tools
		  down                   Remove symlinks for all tools
		  prune                  Remove mise cache volumes

		Symlink invocation:
		  <tool> [args...]       Run via symlink (after 'up')

		Environment:
		  COCO_RUNTIME        Container runtime: podman (default) or docker
		  COCO_DEBUG          Enable debug output (set to 'true' or '1')
		  COCO_ALLOW_NETWORK  Override network restrictions (set to 'true' or '1')
	EOF
}

# =============================================================================
# Tool execution
# =============================================================================

run_tool() {
	TOOL_NAME="$1"
	shift
	REMAINING_ARGS=("$@")

	check_dependencies
	load_config
	build_podman_args

	local image command mise_tool cmd
	image="$(cfg '.image // "docker.io/jdxcode/mise"')"
	command="$(cfg '.command // empty')"
	mise_tool="$(cfg '.tool')"
	cmd="${command:-$TOOL_NAME}"

	exec "$COCO_RUNTIME" "${PODMAN_ARGS[@]}" "$image" x "$mise_tool" -- "$cmd" "${REMAINING_ARGS[@]}"
}

# =============================================================================
# Main
# =============================================================================

main() {
	local script_name
	script_name="$(basename "$0")"

	# Symlink invocation: run as tool directly
	if [[ "$script_name" != "$PRODUCT" ]]; then
		run_tool "$script_name" "$@"
		return
	fi

	# Direct invocation: parse command
	if [[ $# -lt 1 ]]; then
		cmd_help
		exit 1
	fi

	local cmd="$1"
	shift

	case "$cmd" in
	run)
		if [[ $# -lt 1 ]]; then
			die "usage: $PRODUCT run <tool> [args...]"
		fi
		run_tool "$@"
		;;
	list) cmd_list ;;
	up) cmd_up ;;
	down) cmd_down ;;
	prune) cmd_prune ;;
	help | --help | -h) cmd_help ;;
	*) die "unknown command: $cmd (see '$PRODUCT help')" ;;
	esac
}

main "$@"
